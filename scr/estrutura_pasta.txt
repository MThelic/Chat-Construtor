Estrutura da Pasta:
auto-construtor/
    .gitignore
    main.py
    README.md
    requirements.txt
    .git/
        COMMIT_EDITMSG
        config
        description
        FETCH_HEAD
        HEAD
        index
        ORIG_HEAD
        packed-refs
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            sendemail-validate.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    master
                remotes/
                    origin/
                        main
                        master
        objects/
            00/
                fd9059b897a1171e3a2b7566ed94c23d36cc4f
            11/
                cb4d763ec01e61e048c5e66dc1eb38fba1aa1d
            15/
                22136cb498b81a93e388ecf5f4728dfb8107a2
            23/
                4eb9cb143921eda8ad5e9cd394a008a794284f
            24/
                b6ddb8701a1f756de03aa3e34b4e89e63ff93d
            31/
                c354227bb1950b5c24ba77d85111dda970da5a
            45/
                fbd804d26c747650c5cf0477a8e90b3f470490
            47/
                ffd1c6bffaacbbff301a5858a39110fb807fa3
            49/
                8de3a6c1c838096f93efa0633fc203e77b5e9e
            4c/
                fd1acdde6eb9dbd2ef856bf21ef9b68cfe582f
            4f/
                508126f5d05fae9b626c4b6bf6b36ed177e0e2
            53/
                55513387c20a6190159aecea45d5d71752850b
            55/
                18882ec2214c4df1dc8992b84f29e4142be9b9
            57/
                8c92ecd10887ff679584a7f417eb008552e4a4
            5d/
                0d62911ff3ebd1a811e0b85063f8f2560d440c
            63/
                c8f9c004c24f55f42533d175f0123cef361ed4
            72/
                391c3aa23ffb02975ac1e28a8b9dfeb3c97121
            79/
                7db0350818b6705298019dd8ab3728d5e0bd76
            7a/
                d20b8d6f2f83d1237167d585a32e692ceb63c8
            7f/
                423f49658e0e3487959a353039f2c1be9d77ed
            8c/
                9e961935f608127cf5fbc0ee5ea46deda844af
            97/
                2c085adb84424e01748046f90910036cf64b66
            99/
                c16789cf055ea143440f858e512a3c0ed9dc1f
                c2a02fb1334b5c53edfa0d363d28950c5ed201
                df2700d6575212f305ccace96f73eb4ed626d5
            a0/
                d985ce0004195e92c5034b1df6f061d2a38817
            a8/
                5ac41f6133dd8bcaac609eb26c63b3405e3083
            ad/
                1aa58923978d3c39aa02b16169cddf984b55bd
                220be9294589a6c2b56948a0b28e04cdd451b5
            af/
                8cbc50265ce11e2627441c5b0efcfba03bd15c
            b8/
                581c863ef2c294123653af13c5cf122fe139eb
            bb/
                77b8976ff502b75f63005c3c12cd1cf0f4d4a9
            bf/
                65f1023131dd5833ee1192aa14c42ae79665f7
            c3/
                b432e5f9b2bc556ac9c6df418c54f15a49a801
            c6/
                77cb9902dfd93844da8c755c41e62e3522559d
            ce/
                a8b9c53202bf178a5b0cd369f1a29af459c9d3
            db/
                f5583f300a03d745e2c47454fe8013e3f7d013
            e1/
                6e4c0d0d6e369014ee4b9ae562ec140fd7bd40
            e6/
                63eb2d0a056f1cd0f4025cb0b3b396f7f139a2
                9de29bb2d1d6434b8b29ae775ad8c2e48c5391
            eb/
                82a8d9c74035f44802e70d79f5443c094a6b42
                ea88cc4a60680593ab3512f863bb159db6a76d
            ee/
                f5bde97345ef2a4c27eda0c6790ba91079c5ec
            info/
            pack/
                pack-ddea4ba1d93c7e33349d863fe5d6c25e7a6af5f9.idx
                pack-ddea4ba1d93c7e33349d863fe5d6c25e7a6af5f9.pack
                pack-ddea4ba1d93c7e33349d863fe5d6c25e7a6af5f9.rev
        refs/
            heads/
                master
            remotes/
                origin/
                    main
                    master
            tags/
    .streamlit/
        config.toml
    assets/
        logo_dark.png
        logo_dark_2.png
        logo_icone_rgb.ico
        logo_light.png
    base/
        .gitkeep.txt
        estoque.csv
        itens.json
        vendas.csv
        imagens/
    pages/
        em_casa.py
        estrutura.py
        grafico_gauss.py
        listar_codigos.py
        relatorio_em_casa.py
        sobre.py
    scr/
        constantes.py
        estilo.py
        estilos.css
        estrutura_pasta.txt
        gemini.py
        instrucoes_gemini.txt
        ler_pastas.py
        modificar_arquivos.py
        __pycache__/
            constantes.cpython-312.pyc
            estilo.cpython-312.pyc
            gemini.cpython-312.pyc
            ler_pastas.cpython-312.pyc
            modificar_arquivos.cpython-312.pyc



Nome do Arquivo:main.py
Código:import streamlit as st
import scr.gemini
import scr.estilo

scr.estilo.menu_lateral()
st.markdown('## CHAT CONSTRUTOR')

if "messages" not in st.session_state:
    st.session_state.messages = []

user_input = st.chat_input("Digite seu texto:")

if user_input:
    st.session_state.messages.append({"role": "user", "content": user_input})
    response = scr.gemini.call_google_gemini_api('LEMBRE-SE DE TODAS AS INSTRUÇÕES!! '+user_input)
    st.session_state.messages.append({"role": "assistant", "content": response})

for message in st.session_state.messages:
    st.chat_message(message["role"]).markdown(message["content"])

if not user_input and not st.session_state.messages:
    st.chat_message("assistant").markdown("Insira alguma instrução ou pergunte por sugestões")




Nome do Arquivo:em_casa.py
Código:import streamlit as st
import scr.estilo
import json
import os
import pandas as pd
import random
import string

def gerar_chave_aleatoria(tamanho=10):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=tamanho))

scr.estilo.menu_lateral()

st.title("Em Casa")

opcao = st.radio("Selecione uma opção:", ("Vendas", "Estoque"), horizontal=True)

if opcao == "Vendas":
    st.markdown("## Cadastro de Vendas")

    # Gera uma chave aleatória
    chave_aleatoria = gerar_chave_aleatoria()

    # Exibe a chave aleatória
    st.text(f"ID da Venda: {chave_aleatoria}")

    # Lista de itens
    itens = [
        "Berinjela",
        "Mini Pizza",
        "Torta",
        "Esfiha",
        "Pastas Árabes"
    ]

    # Cria a lista suspensa com os itens
    produto = st.selectbox("Produto", itens)

    quantidade = st.number_input("Quantidade", min_value=1, step=1)
    valor_unitario = st.number_input("Valor Unitário", min_value=0.01, step=0.01)
    data_venda = st.date_input("Data da Venda")

    # Botão para salvar venda
    if st.button("Salvar Venda"):
        st.success("Venda salva com sucesso!")

        # Cria o DataFrame com os dados da venda
        data = {'id': [chave_aleatoria], 'produto': [produto], 'quantidade': [quantidade], 'valor_unitario': [valor_unitario], 'data_venda': [data_venda.strftime('%Y-%m-%d')]}
        df = pd.DataFrame(data)

        # Salva o DataFrame em um arquivo CSV
        df.to_csv('base/vendas.csv', mode='a', index=False, header=True)

elif opcao == "Estoque":
    st.markdown("## Cadastro de Estoque")

    # Gera uma chave aleatória para o ID do estoque
    chave_estoque = gerar_chave_aleatoria()

    # Exibe a chave aleatória
    st.text(f"ID do Estoque: {chave_estoque}")

    # Lista de itens
    itens = [
        "Berinjela",
        "Mini Pizza",
        "Torta",
        "Esfiha",
        "Pastas Árabes"
    ]

    # Cria a lista suspensa com os itens
    produto_estoque = st.selectbox("Produto", itens)

    quantidade_estoque = st.number_input("Quantidade", min_value=0, step=1)
    data_entrada = st.date_input("Data de Entrada")

    # Botão para salvar estoque
    if st.button("Salvar Estoque"):
        st.success("Estoque salvo com sucesso!")

        # Cria o DataFrame com os dados do estoque
        data = {'id': [chave_estoque], 'produto': [produto_estoque], 'quantidade': [quantidade_estoque], 'data_entrada': [data_entrada.strftime('%Y-%m-%d')]}
        df = pd.DataFrame(data)

        # Salva o DataFrame em um arquivo CSV
        df.to_csv('base/estoque.csv', mode='a', index=False, header=True)

#FIM DO CÓDIGO




Nome do Arquivo:estrutura.py
Código:import streamlit as st
import scr.estilo
import os

scr.estilo.menu_lateral(pagina="Estrutura do Projeto")
st.title("Estrutura do Projeto")

def gerar_estrutura_diagrama(pasta_raiz):
    """Gera um diagrama da estrutura de pastas e arquivos."""
    estrutura = []
    for root, dirs, files in os.walk(pasta_raiz):
        if '.git' in root or 'pycache' in root: continue
        level = root.replace(pasta_raiz, '').count(os.sep)
        indent = '  ' * level
        estrutura.append(f"{indent}{os.path.basename(root)}/")
        for file in files:
            estrutura.append(f"{indent}  - {file}")
    return estrutura

# Obtém a estrutura do projeto
pasta_raiz = os.getcwd()
estrutura_diagrama = gerar_estrutura_diagrama(pasta_raiz)

# Exibe a estrutura
st.markdown("```\n" + "\n".join(estrutura_diagrama) + "\n```")




Nome do Arquivo:grafico_gauss.py
Código:import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
import scr.estilo

scr.estilo.menu_lateral(pagina="Gráfico Interativo")

st.title("Gráfico Interativo")

st.markdown("""
    Explore diferentes tipos de funções e visualize como seus parâmetros influenciam seu comportamento.
""")

# Lista suspensa para escolher o tipo de função
funcao_escolhida = st.selectbox("Selecione o tipo de função:",
    ("Linear", "Quadrática", "3º Grau", "Senoide", "Circular"))

# Parâmetros da função escolhida
if funcao_escolhida == "Linear":
    a = st.slider("Coeficiente Angular (a)", -5.0, 5.0, 0.0, step=0.1)
    b = st.slider("Coeficiente Linear (b)", -5.0, 5.0, 0.0, step=0.1)
    x = np.linspace(-5, 5, 100)
    y = a * x + b
elif funcao_escolhida == "Quadrática":
    a = st.slider("Coeficiente Quadrático (a)", -5.0, 5.0, 1.0, step=0.1)
    b = st.slider("Coeficiente Linear (b)", -5.0, 5.0, 0.0, step=0.1)
    c = st.slider("Termo Constante (c)", -5.0, 5.0, 0.0, step=0.1)
    x = np.linspace(-5, 5, 100)
    y = a * x**2 + b * x + c
elif funcao_escolhida == "3º Grau":
    a = st.slider("Coeficiente Cúbico (a)", -5.0, 5.0, 1.0, step=0.1)
    b = st.slider("Coeficiente Quadrático (b)", -5.0, 5.0, 0.0, step=0.1)
    c = st.slider("Coeficiente Linear (c)", -5.0, 5.0, 0.0, step=0.1)
    d = st.slider("Termo Constante (d)", -5.0, 5.0, 0.0, step=0.1)
    x = np.linspace(-5, 5, 100)
    y = a * x**3 + b * x**2 + c * x + d
elif funcao_escolhida == "Senoide":
    amplitude = st.slider("Amplitude", 0.1, 5.0, 1.0, step=0.1)
    frequencia = st.slider("Frequência", 0.1, 5.0, 1.0, step=0.1)
    fase = st.slider("Fase", -np.pi, np.pi, 0.0, step=0.1)
    x = np.linspace(0, 2 * np.pi, 100)
    y = amplitude * np.sin(frequencia * x + fase)
elif funcao_escolhida == "Circular":
    raio = st.slider("Raio", 0.1, 5.0, 1.0, step=0.1)
    x = raio * np.cos(np.linspace(0, 2 * np.pi, 100))
    y = raio * np.sin(np.linspace(0, 2 * np.pi, 100))

# Plotagem do gráfico
fig, ax = plt.subplots(figsize=(6, 4)) # Reduz o tamanho do gráfico
ax.plot(x, y, "r-", linewidth=2)
ax.set_xlabel("x")
ax.set_ylabel("f(x)")
ax.set_title(f"Gráfico de {funcao_escolhida}")
ax.grid(True)

# Exibe o gráfico

st.columns([1,4,1])[1].pyplot(fig)

st.markdown("### :tada[Personalize os parâmetros da função usando os sliders! 🎉]")




Nome do Arquivo:listar_codigos.py
Código:import streamlit as st
import os
import scr.estilo
scr.estilo.menu_lateral()

st.title("Lista de Códigos")
st.markdown("## Selecione um arquivo .py para visualizar seu conteúdo:")

arquivos = {}
for root, _, files in os.walk('.'):
    for file in files:
        if file.endswith('.py'):
            arquivos[file] = os.path.join(root, file)

arquivo_selecionado = st.selectbox("Selecione um arquivo:", list(arquivos.keys()))

if arquivo_selecionado:
    with open(arquivos[arquivo_selecionado], "r", encoding='utf-8') as f:
        codigo = f.read()
    st.code(codigo, language="python")



Nome do Arquivo:relatorio_em_casa.py
Código:import streamlit as st
import scr.estilo
import pandas as pd
import scr.gemini
import matplotlib.pyplot as plt

scr.estilo.menu_lateral()

st.title("Relatório em Casa")

# Lê os arquivos CSV
try:
    df_vendas = pd.read_csv("base/vendas.csv")
except FileNotFoundError:
    df_vendas = pd.DataFrame(columns=['id', 'produto', 'quantidade', 'valor_unitario', 'data_venda'])
try:
    df_estoque = pd.read_csv("base/estoque.csv")
except FileNotFoundError:
    df_estoque = pd.DataFrame(columns=['id', 'produto', 'quantidade', 'data_entrada'])

with st.expander("Banco de Dados"):
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("## Vendas")
        st.dataframe(df_vendas)

    with col2:
        st.markdown("## Estoque")
        st.dataframe(df_estoque)

user_input = st.chat_input("Digite seu texto:")

if user_input:
    response = scr.gemini.call_google_gemini_api('LEMBRE-SE DE TODAS AS INSTRUÇÕES!! Faça modificações apenas para a página relatorio_em_casa.py'+user_input)
    st.chat_message("assistant").markdown(response)




Nome do Arquivo:sobre.py
Código:import streamlit as st
import scr.estilo

scr.estilo.menu_lateral(pagina="Sobre o Chat Construtor")

st.title("Sobre o Chat Construtor")

st.markdown("""
    O Chat Construtor é uma ferramenta poderosa para desenvolvedores de aplicações Streamlit. 
    Ele permite que você crie, modifique e gerencie seu projeto de forma rápida e eficiente, 
    usando a inteligência artificial para gerar código automaticamente.

    ## Como funciona?

    O Chat Construtor usa o modelo de linguagem **Gemini** para entender suas instruções e gerar o código Streamlit desejado. 
    Basta digitar seus requisitos e o Chat Construtor fará o resto! 

    ## Recursos:

    * **Geração de Código Automática:** Crie páginas, componentes e funcionalidades com facilidade.
    * **Integração com o Gemini:** Acesse a inteligência artificial avançada do Gemini para obter resultados precisos.
    * **Gerenciamento de Arquivos:** Organize seu projeto com a função de gerenciamento de arquivos.

    ## Começando:

    1. **Digite suas instruções:** Explique o que você deseja que o Chat Construtor faça.
    2. **Revise o código gerado:** Verifique se o código atende às suas necessidades.
    3. **Execute o código:** Execute o código gerado em seu ambiente Streamlit.

    ## Observações:

    * O Chat Construtor ainda está em desenvolvimento. 
    * Se você encontrar algum erro, por favor, relate-o para que possamos melhorá-lo.
    * O Chat Construtor é uma ferramenta poderosa, mas não substitui o conhecimento de programação.

    ## Explore e experimente!
""")

st.markdown(f"### :rainbow[Essa página foi criada automaticamente pelo Chat Construtor! 🎉]")

st.image("https://www.robotlab.com/hubfs/NAO%20V6%20-%20TOP.png",)



Nome do Arquivo:constantes.py
Código:PAGINAS={'main.py': ['Chat Construtor', '💻'], 'pages/sobre.py': ['Sobre o Chat Construtor', '🤖'], 'pages/estrutura.py': ['Estrutura do Projeto', '🗄️'], 'pages/listar_codigos.py': ['Lista de Códigos', '📃'], 'pages/grafico_gauss.py': ['Gráfico Interativo', '📊'], 'pages/em_casa.py': ['Em Casa', '🏠'], 'pages/relatorio_em_casa.py': ['Relatório em Casa', '📊']}



Nome do Arquivo:estilo.py
Código:import streamlit as st
from streamlit.errors import StreamlitAPIException
from PIL import Image
from pathlib import Path
import base64
import scr.constantes

def importar_assets():
    def abrir_imagem(path):
        return Image.open(Path(path))
    def abrir_imagem_base64(path):
        return base64.b64encode(Path(path).read_bytes()).decode()

    assets={
        'logo_ico': abrir_imagem('assets/logo_icone_rgb.ico'),
        'logo_dark': abrir_imagem('assets/logo_dark.png'),
        'logo_light': abrir_imagem('assets/logo_light.png'),
        'logo_dark_base64':abrir_imagem_base64('assets/logo_dark.png')
    }
    return assets

def importar_estilos():
    with open(r"scr/estilos.css", "r") as f:
        css = f.read()
    return css

def aplicar_estilos(*classes, texto="", imagem=None, link=None, link_pagina=None):
    css = importar_estilos()
    classes_str = " ".join(classes)
    if imagem != None:
        elemento = f"<img src=data:image/png;base64,{imagem}>"
    else:
        elemento = texto
    div = f"""<div class="{classes_str}">{elemento}</div>"""
    if link != None:
        div = f"<a href='{link}'>{div}</a>"
    elif link_pagina != None:
        div = f"<a href='{link_pagina}' target='_self'>{div}</a>"

    return f"""<style>{css}</style>{div}"""

def menu_lateral(pagina="Chat Construtor"):
    if pagina != "Chat Construtor" and "Bug Iniciar" not in st.session_state:
        st.session_state["Bug Iniciar"] = True
        st.rerun()
    assets = importar_assets()
    try:
        st.set_page_config(
            page_title="Chat Construtor", page_icon=assets["logo_ico"], layout="wide"
        )
    except StreamlitAPIException:
        pass
    with st.sidebar:
        st.markdown(
            aplicar_estilos(
                "imagens", link_pagina="", imagem=assets["logo_dark_base64"]
            ),
            unsafe_allow_html=True,
        )
        st.divider()
        st.subheader("MENU EM CONSTRUÇÃO")
        for pag, value in scr.constantes.PAGINAS.items():
            try:st.page_link(pag, label=value[0], icon=value[1])
            except Exception as e: st.warning(e)



Nome do Arquivo:gemini.py
Código:import google.generativeai as genai
import scr.ler_pastas
import scr.modificar_arquivos
import os
from google.generativeai.types import HarmCategory, HarmBlockThreshold

genai.configure(api_key="AIzaSyAgG2qM9rDLz00ec5lpysZgVRCz7iZOkLU")

generation_config = { "temperature": 1, "top_p": 0.95, "top_k": 64, "max_output_tokens": 8192, "response_mime_type": "text/plain"}

model = genai.GenerativeModel( model_name="gemini-1.5-flash", generation_config=generation_config,safety_settings={HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_ONLY_HIGH})

instrucoes = open(r'scr/instrucoes_gemini.txt', 'r', encoding='utf-8').read()
codigo_atual=scr.ler_pastas.read_folder_structure_and_files()

chat_session = model.start_chat( history=[ { "role": "user", "parts": [instrucoes + codigo_atual]}])

def call_google_gemini_api(text):
    response = chat_session.send_message(text)
    response_text = response.text
    
    return scr.modificar_arquivos.ler_resposta(response_text)



Nome do Arquivo:ler_pastas.py
Código:import os

def read_folder_structure_and_files():
    folder_path = os.getcwd()
    print(folder_path)
    folder_structure = []
    python_files = []

    # Coletando a estrutura das pastas e arquivos Python
    for root, dirs, files in os.walk(folder_path):
        level = root.replace(folder_path, '').count(os.sep)
        indent = ' ' * 4 * level
        folder_structure.append(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for file in files:
            folder_structure.append(f"{subindent}{file}")
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                python_files.append(file_path)

    # Construindo o conteúdo a ser retornado
    output_content = "Estrutura da Pasta:\n"
    output_content += "\n".join(folder_structure)
    output_content += "\n\n"

    for file_path in python_files:
        with open(file_path, 'r', encoding='utf-8') as py_file:
            file_content = py_file.read()
            output_content += "\n\n"
            output_content += f"Nome do Arquivo:{os.path.basename(file_path)}\n"
            output_content += f"Código:{file_content}\n\n"
    open(r'scr/estrutura_pasta.txt', 'w', encoding='utf-8').write(output_content)

    return output_content




Nome do Arquivo:modificar_arquivos.py
Código:import os
import shutil
import scr.constantes

def add_pagina(configuracao):
    pag=scr.constantes.PAGINAS
    pag[configuracao[0]]=[configuracao[1],configuracao[2]]
    open(r"scr/constantes.py", "w", encoding='utf-8').write("PAGINAS="+str(pag))

def remover_pagina(value):
    pag=scr.constantes.PAGINAS
    pag.pop(value)
    open(r"scr/constantes.py", "w", encoding='utf-8').write("PAGINAS="+str(pag))

def executar_comando(key,value):
    if key=='chat':
        return f'Resposta: {value}'
    elif key=='criar':
        value=value.strip()
        os.makedirs(value, exist_ok=True)
        return f'Pasta {value} criada'
    elif key=='deletar':
        value=value.strip()
        caminho=os.path.abspath(value)
        if os.path.isfile(caminho):
            os.remove(caminho)
            if 'pages' in value: remover_pagina(value)
        elif os.path.isdir(caminho): shutil.rmtree(caminho)
        else: return f'O caminho {value} não existe.'
        return f'Pasta {value} excluída'
    elif ',' in key:
        configuracao=key.split(',')
        add_pagina(configuracao)
        conteudo = value+'import scr.estilo' if 'import scr.estilo'not in value else value
        conteudo = conteudo+'scr.estilo.menu_lateral()' if 'scr.estilo.menu_lateral('not in value else conteudo
        open(f"{configuracao[0]}", "w", encoding='utf-8').write(conteudo)
        return f'Página {configuracao[2]} {configuracao[1]}'
    else:
        open(f"{key}", "w", encoding='utf-8').write(value)
        return f'Arquivo {key} criado'

def ler_resposta(response_text):
    mensagens=[]
    lista=response_text.split('$')
    dicionario = {item: lista[i + 1].strip('|') for i, item in enumerate(lista) if item and item[0] != '|'}
    for key in dicionario:
        mensagens.append(executar_comando(key,dicionario[key]))
    return "\n".join(mensagens)


